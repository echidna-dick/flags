0x08048800 <+0>:  mov    eax, DWORD PTR [ebp+0x8]   ; (arument) int x
0x08048803 <+3>:  cmp    eax, 0x10                  ; x < 16
0x08048806 <+6>:  jl     0x08048810                 ; jump if x is less then 16 ps you forgot the zero in 0x here-> 0 8048810
0x08048808 <+8>:  mov    eax, 0                     ; return 0
0x0804880d <+13>: jmp    0x8048815
0x08048810 <+16>: mov    eax, 1                     ; return 1
0x08048815 <+21>: ret
================================================================
in C:
    int check(int x){
        if(x<16){
            return 1;
        }
        return 0;
    }
=================================================================
how CF and OF work:
                            CF
if we use al (8-bits) but also we have ax (16-bit), eax (32-bit), rax (64-bit)

so if we use al:
    mov al, 0xFF
    add al, 0x1
        so in binary:
            11111111    ; 255 max 8-bit value!
           +00000001    ; + 1 bit = overflow
          ----------
          1 00000000
so the register is only 8-bit, so it stores just 00000000
that extra 1 on the left is the carry out -> goes in CF.
so CF = 1

SIGNED RANGE
for 8-bit singed numbers:
    minimum = 10000000 = -128
    maximum = 01111111 = +127
so if we add 127 + 1, we should get 128, what is not possible in 8-bit singed, so we wrap it to 100000000 = -128

thats nonsence in signed math ->  OF = 1
unsinged math sees it as 128 -> which is fine -> CF = 0

SIGNED AND UNSIGNED MATH:
    unsigned: (0 -> 255)
        00000000 = 0
        11111111 = 255
    signed:   (two's complement (-128 -> + 127))
        00000000 = 0
        01111111 = +127
        10000000 = -127
        11111111 = -1

    Unsigned vs signed range
If you have N bits, you get 2^N possible patterns.

Unsigned:
All bit patterns are used for nonnegative values.

    8 bits → 0 … 255
    32 bits → 0 … 4,294,967,295


Signed (two’s complement):
Half of the patterns are negative, half positive.

    8 bits → -128 … +127
    32 bits → -2,147,483,648 … +2,147,483,647

#TIP!
    Unsigned jumps check the Carry Flag (CF).
    Signed jumps check the Overflow Flag (OF) and Sign Flag (SF).

                            TABLE OF CONDITION JUMPS:
Mnemonic:               Meaning:                            Type:        Flag:
JE/JZ       	Jump if Equal / Zero	                     Any	    ZF = 1
JNE/JNZ     	Jump if Not Equal / Not Zero	             Any	    ZF = 0
JA              Jump if Above (unsigned >)	               Unsigned	    CF = 0 and ZF = 0
JAE/JNB     	Jump if Above or Equal (unsigned ≥)	       Unsigned	    CF = 0
JB/JNAE     	Jump if Below (unsigned <)	               Unsigned	    CF = 1
JBE/JNA     	Jump if Below or Equal (unsigned ≤)	       Unsigned	    CF = 1 or ZF = 1
JG          	Jump if Greater (signed >)	               Signed	    ZF = 0 and SF = OF
JGE         	Jump if Greater or Equal (signed ≥)	       Signed	    SF = OF
JL          	Jump if Less (signed <)	                   Signed	    SF != OF
JLE	            Jump if Less or Equal (signed ≤)	       Signed	    ZF = 1 or SF != OF

                            OTHER USEFULL ONES:
JC	            Jump if Carry	                                        CF = 1
JNC	            Jump if No Carry	                                    CF = 0
JO	            Jump if Overflow	                                    OF = 1
JNO	            Jump if No Overflow	                                    OF = 0
JS	            Jump if Sign	                                        SF = 1
JNS	            Jump if Not Sign	                                    SF = 0

Binary	            Hex	     Unsigned	Signed (two’s complement)
00000000	       0x00	       0	      0
00000001	       0x01	       1	      1
01111111	       0x7F	       127	     127
10000000	       0x80	       128	    -128
10000001	       0x81	       129	    -127
11111110	       0xFE	       254	     -2
11111111	       0xFF	       255	     -1
